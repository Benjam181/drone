ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 1
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"accelerometer.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.file 1 "Core/Src/accelerometer.c"
  20              		.section	.text.Accelerometer_Init,"ax",%progbits
  21              		.align	1
  22              		.global	Accelerometer_Init
  23              		.syntax unified
  24              		.thumb
  25              		.thumb_func
  27              	Accelerometer_Init:
  28              	.LVL0:
  29              	.LFB132:
   1:Core/Src/accelerometer.c **** #include "accelerometer.h"
   2:Core/Src/accelerometer.c **** 
   3:Core/Src/accelerometer.c **** #define MPU6050_ADDR (0x68 << 1) // Adresse I2C en 8 bits
   4:Core/Src/accelerometer.c **** 
   5:Core/Src/accelerometer.c **** /**
   6:Core/Src/accelerometer.c ****  * @brief Initializes the accelerometer hardware and configures its settings.
   7:Core/Src/accelerometer.c ****  *
   8:Core/Src/accelerometer.c ****  * This function sets up the accelerometer by configuring the necessary hardware
   9:Core/Src/accelerometer.c ****  * registers, communication interfaces (such as I2C or SPI), and any required
  10:Core/Src/accelerometer.c ****  * initialization parameters. It prepares the accelerometer for data acquisition
  11:Core/Src/accelerometer.c ****  * and ensures it is ready for operation.
  12:Core/Src/accelerometer.c ****  *
  13:Core/Src/accelerometer.c ****  * @note This function should be called before attempting to read data from the accelerometer.
  14:Core/Src/accelerometer.c ****  */
  15:Core/Src/accelerometer.c **** void Accelerometer_Init(I2C_HandleTypeDef *hi2c)
  16:Core/Src/accelerometer.c **** {
  30              		.loc 1 16 1 view -0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 8
  33              		@ frame_needed = 0, uses_anonymous_args = 0
  34              		.loc 1 16 1 is_stmt 0 view .LVU1
  35 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  36              		.cfi_def_cfa_offset 24
  37              		.cfi_offset 4, -24
  38              		.cfi_offset 5, -20
  39              		.cfi_offset 6, -16
  40              		.cfi_offset 7, -12
  41              		.cfi_offset 8, -8
  42              		.cfi_offset 14, -4
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 2


  43 0004 86B0     		sub	sp, sp, #24
  44              		.cfi_def_cfa_offset 48
  45 0006 0446     		mov	r4, r0
  17:Core/Src/accelerometer.c ****     uint8_t data = 0;
  46              		.loc 1 17 5 is_stmt 1 view .LVU2
  47              		.loc 1 17 13 is_stmt 0 view .LVU3
  48 0008 0023     		movs	r3, #0
  49 000a 8DF81730 		strb	r3, [sp, #23]
  18:Core/Src/accelerometer.c ****     uint8_t check;
  50              		.loc 1 18 5 is_stmt 1 view .LVU4
  19:Core/Src/accelerometer.c ****     // Read WHO_AM_I register (0x75) to check if the device is connected
  20:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Read(hi2c, MPU6050_ADDR, 0x75, 1, &check, 1, 1000);
  51              		.loc 1 20 5 view .LVU5
  52 000e 4FF47A73 		mov	r3, #1000
  53 0012 0293     		str	r3, [sp, #8]
  54 0014 0123     		movs	r3, #1
  55 0016 0193     		str	r3, [sp, #4]
  56 0018 0DF11602 		add	r2, sp, #22
  57 001c 0092     		str	r2, [sp]
  58 001e 7522     		movs	r2, #117
  59 0020 D021     		movs	r1, #208
  60 0022 FFF7FEFF 		bl	HAL_I2C_Mem_Read
  61              	.LVL1:
  21:Core/Src/accelerometer.c ****     if (check != 0x68) {
  62              		.loc 1 21 5 view .LVU6
  63              		.loc 1 21 15 is_stmt 0 view .LVU7
  64 0026 9DF81630 		ldrb	r3, [sp, #22]	@ zero_extendqisi2
  65              		.loc 1 21 8 view .LVU8
  66 002a 682B     		cmp	r3, #104
  67 002c 02D0     		beq	.L5
  68              	.L1:
  22:Core/Src/accelerometer.c ****         // Device not found, handle error
  23:Core/Src/accelerometer.c ****         return;
  24:Core/Src/accelerometer.c ****     }
  25:Core/Src/accelerometer.c ****     // PWR_MGMT_1 Register (0x6B) : wake-up
  26:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Write(hi2c, MPU6050_ADDR, 0x6B, 1, &data, 1, 1000);
  27:Core/Src/accelerometer.c ****     // Set DATA RATE of 1kHz by writing SMPLRT_DIV register
  28:Core/Src/accelerometer.c ****     data = 0x07; // 1000 Hz / (1 + 7) = 125 Hz
  29:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Write(hi2c, MPU6050_ADDR, 0x19, 1, &data, 1, 1000);
  30:Core/Src/accelerometer.c ****     // Set accelerometer configuration in ACCEL_CONFIG Register (0x1C)
  31:Core/Src/accelerometer.c ****     data = 0x00; // ±2g full scale
  32:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Write(hi2c, MPU6050_ADDR, 0x1C, 1, &data, 1, 1000);
  33:Core/Src/accelerometer.c ****     // set Gyroscopic configuration in GYRO_CONFIG Register (0x1B)
  34:Core/Src/accelerometer.c ****     data = 0x00; // ±250°/s full scale
  35:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Write(hi2c, MPU6050_ADDR, 0x1B, 1, &data, 1, 1000);
  36:Core/Src/accelerometer.c **** }
  69              		.loc 1 36 1 view .LVU9
  70 002e 06B0     		add	sp, sp, #24
  71              		.cfi_remember_state
  72              		.cfi_def_cfa_offset 24
  73              		@ sp needed
  74 0030 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
  75              	.LVL2:
  76              	.L5:
  77              		.cfi_restore_state
  26:Core/Src/accelerometer.c ****     // Set DATA RATE of 1kHz by writing SMPLRT_DIV register
  78              		.loc 1 26 5 is_stmt 1 view .LVU10
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 3


  79 0034 4FF47A77 		mov	r7, #1000
  80 0038 0297     		str	r7, [sp, #8]
  81 003a 0125     		movs	r5, #1
  82 003c 0195     		str	r5, [sp, #4]
  83 003e 0DF11706 		add	r6, sp, #23
  84 0042 0096     		str	r6, [sp]
  85 0044 2B46     		mov	r3, r5
  86 0046 6B22     		movs	r2, #107
  87 0048 D021     		movs	r1, #208
  88 004a 2046     		mov	r0, r4
  89 004c FFF7FEFF 		bl	HAL_I2C_Mem_Write
  90              	.LVL3:
  28:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Write(hi2c, MPU6050_ADDR, 0x19, 1, &data, 1, 1000);
  91              		.loc 1 28 5 view .LVU11
  28:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Write(hi2c, MPU6050_ADDR, 0x19, 1, &data, 1, 1000);
  92              		.loc 1 28 10 is_stmt 0 view .LVU12
  93 0050 0723     		movs	r3, #7
  94 0052 8DF81730 		strb	r3, [sp, #23]
  29:Core/Src/accelerometer.c ****     // Set accelerometer configuration in ACCEL_CONFIG Register (0x1C)
  95              		.loc 1 29 5 is_stmt 1 view .LVU13
  96 0056 0297     		str	r7, [sp, #8]
  97 0058 0195     		str	r5, [sp, #4]
  98 005a 0096     		str	r6, [sp]
  99 005c 2B46     		mov	r3, r5
 100 005e 1922     		movs	r2, #25
 101 0060 D021     		movs	r1, #208
 102 0062 2046     		mov	r0, r4
 103 0064 FFF7FEFF 		bl	HAL_I2C_Mem_Write
 104              	.LVL4:
  31:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Write(hi2c, MPU6050_ADDR, 0x1C, 1, &data, 1, 1000);
 105              		.loc 1 31 5 view .LVU14
  31:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Write(hi2c, MPU6050_ADDR, 0x1C, 1, &data, 1, 1000);
 106              		.loc 1 31 10 is_stmt 0 view .LVU15
 107 0068 4FF00008 		mov	r8, #0
 108 006c 8DF81780 		strb	r8, [sp, #23]
  32:Core/Src/accelerometer.c ****     // set Gyroscopic configuration in GYRO_CONFIG Register (0x1B)
 109              		.loc 1 32 5 is_stmt 1 view .LVU16
 110 0070 0297     		str	r7, [sp, #8]
 111 0072 0195     		str	r5, [sp, #4]
 112 0074 0096     		str	r6, [sp]
 113 0076 2B46     		mov	r3, r5
 114 0078 1C22     		movs	r2, #28
 115 007a D021     		movs	r1, #208
 116 007c 2046     		mov	r0, r4
 117 007e FFF7FEFF 		bl	HAL_I2C_Mem_Write
 118              	.LVL5:
  34:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Write(hi2c, MPU6050_ADDR, 0x1B, 1, &data, 1, 1000);
 119              		.loc 1 34 5 view .LVU17
  34:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Write(hi2c, MPU6050_ADDR, 0x1B, 1, &data, 1, 1000);
 120              		.loc 1 34 10 is_stmt 0 view .LVU18
 121 0082 8DF81780 		strb	r8, [sp, #23]
  35:Core/Src/accelerometer.c **** }
 122              		.loc 1 35 5 is_stmt 1 view .LVU19
 123 0086 0297     		str	r7, [sp, #8]
 124 0088 0195     		str	r5, [sp, #4]
 125 008a 0096     		str	r6, [sp]
 126 008c 2B46     		mov	r3, r5
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 4


 127 008e 1B22     		movs	r2, #27
 128 0090 D021     		movs	r1, #208
 129 0092 2046     		mov	r0, r4
 130 0094 FFF7FEFF 		bl	HAL_I2C_Mem_Write
 131              	.LVL6:
 132 0098 C9E7     		b	.L1
 133              		.cfi_endproc
 134              	.LFE132:
 136              		.section	.text.Accelerometer_Read,"ax",%progbits
 137              		.align	1
 138              		.global	Accelerometer_Read
 139              		.syntax unified
 140              		.thumb
 141              		.thumb_func
 143              	Accelerometer_Read:
 144              	.LVL7:
 145              	.LFB133:
  37:Core/Src/accelerometer.c **** 
  38:Core/Src/accelerometer.c **** /**
  39:Core/Src/accelerometer.c ****  * @brief Reads the current acceleration values from the accelerometer sensor.
  40:Core/Src/accelerometer.c ****  *
  41:Core/Src/accelerometer.c ****  * This function communicates with the accelerometer hardware to retrieve the latest
  42:Core/Src/accelerometer.c ****  * acceleration data, typically along the X, Y, and Z axes. The retrieved values can be
  43:Core/Src/accelerometer.c ****  * used for motion detection, orientation sensing, or other applications requiring
  44:Core/Src/accelerometer.c ****  * acceleration information.
  45:Core/Src/accelerometer.c ****  *
  46:Core/Src/accelerometer.c ****  * @return int Returns 0 on success, or a negative error code on failure.
  47:Core/Src/accelerometer.c ****  */
  48:Core/Src/accelerometer.c **** void Accelerometer_Read(I2C_HandleTypeDef *hi2c, AccelData *accel_data, GyroData *gyro_data)
  49:Core/Src/accelerometer.c **** {    
 146              		.loc 1 49 1 view -0
 147              		.cfi_startproc
 148              		@ args = 0, pretend = 0, frame = 8
 149              		@ frame_needed = 0, uses_anonymous_args = 0
 150              		.loc 1 49 1 is_stmt 0 view .LVU21
 151 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 152              		.cfi_def_cfa_offset 28
 153              		.cfi_offset 4, -28
 154              		.cfi_offset 5, -24
 155              		.cfi_offset 6, -20
 156              		.cfi_offset 7, -16
 157              		.cfi_offset 8, -12
 158              		.cfi_offset 9, -8
 159              		.cfi_offset 14, -4
 160 0004 87B0     		sub	sp, sp, #28
 161              		.cfi_def_cfa_offset 56
 162 0006 0646     		mov	r6, r0
 163 0008 0D46     		mov	r5, r1
 164 000a 1446     		mov	r4, r2
  50:Core/Src/accelerometer.c ****     uint8_t Rec_Data[6];
 165              		.loc 1 50 5 is_stmt 1 view .LVU22
  51:Core/Src/accelerometer.c **** 
  52:Core/Src/accelerometer.c ****     // Read 6 BYTES of data starting from ACCEL_XOUT_H (0x3B) Register
  53:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Read(hi2c, MPU6050_ADDR, 0x3B, 1, Rec_Data, 6, 1000);
 166              		.loc 1 53 5 view .LVU23
 167 000c 4FF47A79 		mov	r9, #1000
 168 0010 CDF80890 		str	r9, [sp, #8]
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 5


 169 0014 4FF00608 		mov	r8, #6
 170 0018 CDF80480 		str	r8, [sp, #4]
 171 001c 04AF     		add	r7, sp, #16
 172 001e 0097     		str	r7, [sp]
 173 0020 0123     		movs	r3, #1
 174 0022 3B22     		movs	r2, #59
 175              	.LVL8:
 176              		.loc 1 53 5 is_stmt 0 view .LVU24
 177 0024 D021     		movs	r1, #208
 178              	.LVL9:
 179              		.loc 1 53 5 view .LVU25
 180 0026 FFF7FEFF 		bl	HAL_I2C_Mem_Read
 181              	.LVL10:
  54:Core/Src/accelerometer.c ****     // Convert the data to 16-bit signed integers
  55:Core/Src/accelerometer.c ****     accel_data->x = (int16_t)((Rec_Data[0] << 8) | Rec_Data[1]);
 182              		.loc 1 55 5 is_stmt 1 view .LVU26
 183              		.loc 1 55 40 is_stmt 0 view .LVU27
 184 002a 9DF81020 		ldrb	r2, [sp, #16]	@ zero_extendqisi2
 185              		.loc 1 55 60 view .LVU28
 186 002e 9DF81130 		ldrb	r3, [sp, #17]	@ zero_extendqisi2
 187              		.loc 1 55 21 view .LVU29
 188 0032 43EA0223 		orr	r3, r3, r2, lsl #8
 189 0036 1BB2     		sxth	r3, r3
 190              		.loc 1 55 19 view .LVU30
 191 0038 07EE903A 		vmov	s15, r3	@ int
 192 003c F8EEE76A 		vcvt.f32.s32	s13, s15
 193 0040 C5ED006A 		vstr.32	s13, [r5]
  56:Core/Src/accelerometer.c ****     accel_data->y = (int16_t)((Rec_Data[2] << 8) | Rec_Data[3]);
 194              		.loc 1 56 5 is_stmt 1 view .LVU31
 195              		.loc 1 56 40 is_stmt 0 view .LVU32
 196 0044 9DF81220 		ldrb	r2, [sp, #18]	@ zero_extendqisi2
 197              		.loc 1 56 60 view .LVU33
 198 0048 9DF81330 		ldrb	r3, [sp, #19]	@ zero_extendqisi2
 199              		.loc 1 56 21 view .LVU34
 200 004c 43EA0223 		orr	r3, r3, r2, lsl #8
 201 0050 1BB2     		sxth	r3, r3
 202              		.loc 1 56 19 view .LVU35
 203 0052 07EE903A 		vmov	s15, r3	@ int
 204 0056 B8EEE77A 		vcvt.f32.s32	s14, s15
 205 005a 85ED017A 		vstr.32	s14, [r5, #4]
  57:Core/Src/accelerometer.c ****     accel_data->z = (int16_t)((Rec_Data[4] << 8) | Rec_Data[5]);
 206              		.loc 1 57 5 is_stmt 1 view .LVU36
 207              		.loc 1 57 40 is_stmt 0 view .LVU37
 208 005e 9DF81420 		ldrb	r2, [sp, #20]	@ zero_extendqisi2
 209              		.loc 1 57 60 view .LVU38
 210 0062 9DF81530 		ldrb	r3, [sp, #21]	@ zero_extendqisi2
 211              		.loc 1 57 21 view .LVU39
 212 0066 43EA0223 		orr	r3, r3, r2, lsl #8
 213 006a 1BB2     		sxth	r3, r3
 214              		.loc 1 57 19 view .LVU40
 215 006c 07EE903A 		vmov	s15, r3	@ int
 216 0070 F8EEE77A 		vcvt.f32.s32	s15, s15
 217 0074 C5ED027A 		vstr.32	s15, [r5, #8]
  58:Core/Src/accelerometer.c ****     // Convert raw value to g-force
  59:Core/Src/accelerometer.c ****     accel_data->x = (float)accel_data->x / 16384.0f; // For ±2g full scale
 218              		.loc 1 59 5 is_stmt 1 view .LVU41
 219              		.loc 1 59 42 is_stmt 0 view .LVU42
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 6


 220 0078 9FED286A 		vldr.32	s12, .L8
 221 007c 66EE866A 		vmul.f32	s13, s13, s12
 222              		.loc 1 59 19 view .LVU43
 223 0080 C5ED006A 		vstr.32	s13, [r5]
  60:Core/Src/accelerometer.c ****     accel_data->y = (float)accel_data->y / 16384.0f; 
 224              		.loc 1 60 5 is_stmt 1 view .LVU44
 225              		.loc 1 60 42 is_stmt 0 view .LVU45
 226 0084 27EE067A 		vmul.f32	s14, s14, s12
 227              		.loc 1 60 19 view .LVU46
 228 0088 85ED017A 		vstr.32	s14, [r5, #4]
  61:Core/Src/accelerometer.c ****     accel_data->z = (float)accel_data->z / 16384.0f;
 229              		.loc 1 61 5 is_stmt 1 view .LVU47
 230              		.loc 1 61 42 is_stmt 0 view .LVU48
 231 008c 67EE867A 		vmul.f32	s15, s15, s12
 232              		.loc 1 61 19 view .LVU49
 233 0090 C5ED027A 		vstr.32	s15, [r5, #8]
  62:Core/Src/accelerometer.c **** 
  63:Core/Src/accelerometer.c ****     // Read 6 BYTES of data starting from GYRO_XOUT_H (0x43) Register
  64:Core/Src/accelerometer.c ****     HAL_I2C_Mem_Read(hi2c, MPU6050_ADDR, 0x43, 1, Rec_Data, 6, 1000);
 234              		.loc 1 64 5 is_stmt 1 view .LVU50
 235 0094 CDF80890 		str	r9, [sp, #8]
 236 0098 CDF80480 		str	r8, [sp, #4]
 237 009c 0097     		str	r7, [sp]
 238 009e 0123     		movs	r3, #1
 239 00a0 4322     		movs	r2, #67
 240 00a2 D021     		movs	r1, #208
 241 00a4 3046     		mov	r0, r6
 242 00a6 FFF7FEFF 		bl	HAL_I2C_Mem_Read
 243              	.LVL11:
  65:Core/Src/accelerometer.c ****     // Convert the data to 16-bit signed integers
  66:Core/Src/accelerometer.c ****     gyro_data->x = (int16_t)((Rec_Data[0] << 8) | Rec_Data[1]);
 244              		.loc 1 66 5 view .LVU51
 245              		.loc 1 66 39 is_stmt 0 view .LVU52
 246 00aa 9DF81020 		ldrb	r2, [sp, #16]	@ zero_extendqisi2
 247              		.loc 1 66 59 view .LVU53
 248 00ae 9DF81130 		ldrb	r3, [sp, #17]	@ zero_extendqisi2
 249              		.loc 1 66 20 view .LVU54
 250 00b2 43EA0223 		orr	r3, r3, r2, lsl #8
 251 00b6 1BB2     		sxth	r3, r3
 252              		.loc 1 66 18 view .LVU55
 253 00b8 07EE903A 		vmov	s15, r3	@ int
 254 00bc F8EEE76A 		vcvt.f32.s32	s13, s15
 255 00c0 C4ED006A 		vstr.32	s13, [r4]
  67:Core/Src/accelerometer.c ****     gyro_data->y = (int16_t)((Rec_Data[2] << 8) | Rec_Data[3]);
 256              		.loc 1 67 5 is_stmt 1 view .LVU56
 257              		.loc 1 67 39 is_stmt 0 view .LVU57
 258 00c4 9DF81220 		ldrb	r2, [sp, #18]	@ zero_extendqisi2
 259              		.loc 1 67 59 view .LVU58
 260 00c8 9DF81330 		ldrb	r3, [sp, #19]	@ zero_extendqisi2
 261              		.loc 1 67 20 view .LVU59
 262 00cc 43EA0223 		orr	r3, r3, r2, lsl #8
 263 00d0 1BB2     		sxth	r3, r3
 264              		.loc 1 67 18 view .LVU60
 265 00d2 07EE903A 		vmov	s15, r3	@ int
 266 00d6 B8EEE77A 		vcvt.f32.s32	s14, s15
 267 00da 84ED017A 		vstr.32	s14, [r4, #4]
  68:Core/Src/accelerometer.c ****     gyro_data->z = (int16_t)((Rec_Data[4] << 8) | Rec_Data[5]);
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 7


 268              		.loc 1 68 5 is_stmt 1 view .LVU61
 269              		.loc 1 68 39 is_stmt 0 view .LVU62
 270 00de 9DF81420 		ldrb	r2, [sp, #20]	@ zero_extendqisi2
 271              		.loc 1 68 59 view .LVU63
 272 00e2 9DF81530 		ldrb	r3, [sp, #21]	@ zero_extendqisi2
 273              		.loc 1 68 20 view .LVU64
 274 00e6 43EA0223 		orr	r3, r3, r2, lsl #8
 275 00ea 1BB2     		sxth	r3, r3
 276              		.loc 1 68 18 view .LVU65
 277 00ec 07EE903A 		vmov	s15, r3	@ int
 278 00f0 F8EEE77A 		vcvt.f32.s32	s15, s15
 279 00f4 C4ED027A 		vstr.32	s15, [r4, #8]
  69:Core/Src/accelerometer.c ****     // Convert raw value to degrees per second
  70:Core/Src/accelerometer.c ****     gyro_data->x = (float)gyro_data->x / 131.0f; // For ±250°/s full scale
 280              		.loc 1 70 5 is_stmt 1 view .LVU66
 281              		.loc 1 70 40 is_stmt 0 view .LVU67
 282 00f8 9FED096A 		vldr.32	s12, .L8+4
 283 00fc C6EE865A 		vdiv.f32	s11, s13, s12
 284              		.loc 1 70 18 view .LVU68
 285 0100 C4ED005A 		vstr.32	s11, [r4]
  71:Core/Src/accelerometer.c ****     gyro_data->y = (float)gyro_data->y / 131.0f;
 286              		.loc 1 71 5 is_stmt 1 view .LVU69
 287              		.loc 1 71 40 is_stmt 0 view .LVU70
 288 0104 C7EE066A 		vdiv.f32	s13, s14, s12
 289              		.loc 1 71 18 view .LVU71
 290 0108 C4ED016A 		vstr.32	s13, [r4, #4]
  72:Core/Src/accelerometer.c ****     gyro_data->z = (float)gyro_data->z / 131.0f; 
 291              		.loc 1 72 5 is_stmt 1 view .LVU72
 292              		.loc 1 72 40 is_stmt 0 view .LVU73
 293 010c 87EE867A 		vdiv.f32	s14, s15, s12
 294              		.loc 1 72 18 view .LVU74
 295 0110 84ED027A 		vstr.32	s14, [r4, #8]
  73:Core/Src/accelerometer.c **** }
 296              		.loc 1 73 1 view .LVU75
 297 0114 07B0     		add	sp, sp, #28
 298              		.cfi_def_cfa_offset 28
 299              		@ sp needed
 300 0116 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 301              	.LVL12:
 302              	.L9:
 303              		.loc 1 73 1 view .LVU76
 304 011a 00BF     		.align	2
 305              	.L8:
 306 011c 00008038 		.word	947912704
 307 0120 00000343 		.word	1124270080
 308              		.cfi_endproc
 309              	.LFE133:
 311              		.section	.text.angles_from_accel,"ax",%progbits
 312              		.align	1
 313              		.global	angles_from_accel
 314              		.syntax unified
 315              		.thumb
 316              		.thumb_func
 318              	angles_from_accel:
 319              	.LVL13:
 320              	.LFB134:
  74:Core/Src/accelerometer.c **** 
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 8


  75:Core/Src/accelerometer.c **** /**
  76:Core/Src/accelerometer.c ****  * @brief Calculates the pitch and roll angles from accelerometer data.
  77:Core/Src/accelerometer.c ****  *
  78:Core/Src/accelerometer.c ****  * This function computes the pitch and roll angles based on the accelerometer's
  79:Core/Src/accelerometer.c ****  * x, y, and z axis readings. The angles are calculated using trigonometric functions
  80:Core/Src/accelerometer.c ****  * to determine the orientation of the device in space.
  81:Core/Src/accelerometer.c ****  *
  82:Core/Src/accelerometer.c ****  * @param accel_data Structure containing accelerometer data (x, y, z).
  83:Core/Src/accelerometer.c ****  * @param pitch Pointer to store the calculated pitch angle (in degrees).
  84:Core/Src/accelerometer.c ****  * @param roll Pointer to store the calculated roll angle (in degrees).
  85:Core/Src/accelerometer.c ****  */
  86:Core/Src/accelerometer.c **** void angles_from_accel(AccelData accel_data, float *pitch, float *roll) {
 321              		.loc 1 86 73 is_stmt 1 view -0
 322              		.cfi_startproc
 323              		@ args = 0, pretend = 0, frame = 16
 324              		@ frame_needed = 0, uses_anonymous_args = 0
 325              		.loc 1 86 73 is_stmt 0 view .LVU78
 326 0000 30B5     		push	{r4, r5, lr}
 327              		.cfi_def_cfa_offset 12
 328              		.cfi_offset 4, -12
 329              		.cfi_offset 5, -8
 330              		.cfi_offset 14, -4
 331 0002 2DED048B 		vpush.64	{d8, d9}
 332              		.cfi_def_cfa_offset 28
 333              		.cfi_offset 80, -28
 334              		.cfi_offset 81, -24
 335              		.cfi_offset 82, -20
 336              		.cfi_offset 83, -16
 337 0006 85B0     		sub	sp, sp, #20
 338              		.cfi_def_cfa_offset 48
 339 0008 B0EE409A 		vmov.f32	s18, s0
 340 000c B0EE608A 		vmov.f32	s16, s1
 341 0010 0546     		mov	r5, r0
 342 0012 0C46     		mov	r4, r1
 343 0014 8DED010A 		vstr.32	s0, [sp, #4]
 344 0018 CDED020A 		vstr.32	s1, [sp, #8]
 345 001c 8DED031A 		vstr.32	s2, [sp, #12]
  87:Core/Src/accelerometer.c ****     *pitch = atan2f(accel_data.y, sqrtf(accel_data.x * accel_data.x + accel_data.z * accel_data.z))
 346              		.loc 1 87 5 is_stmt 1 view .LVU79
 347              		.loc 1 87 54 is_stmt 0 view .LVU80
 348 0020 20EE000A 		vmul.f32	s0, s0, s0
 349              		.loc 1 87 84 view .LVU81
 350 0024 61EE018A 		vmul.f32	s17, s2, s2
 351              		.loc 1 87 14 view .LVU82
 352 0028 30EE280A 		vadd.f32	s0, s0, s17
 353 002c FFF7FEFF 		bl	sqrtf
 354              	.LVL14:
 355              		.loc 1 87 14 view .LVU83
 356 0030 F0EE400A 		vmov.f32	s1, s0
 357              		.loc 1 87 14 discriminator 1 view .LVU84
 358 0034 B0EE480A 		vmov.f32	s0, s16
 359 0038 FFF7FEFF 		bl	atan2f
 360              	.LVL15:
 361 003c 10EE100A 		vmov	r0, s0
 362              		.loc 1 87 14 discriminator 2 view .LVU85
 363 0040 FFF7FEFF 		bl	__aeabi_f2d
 364              	.LVL16:
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 9


 365              		.loc 1 87 101 discriminator 2 view .LVU86
 366 0044 12A3     		adr	r3, .L12
 367 0046 D3E90023 		ldrd	r2, [r3]
 368 004a FFF7FEFF 		bl	__aeabi_dmul
 369              	.LVL17:
 370 004e FFF7FEFF 		bl	__aeabi_d2f
 371              	.LVL18:
 372              		.loc 1 87 12 discriminator 2 view .LVU87
 373 0052 2860     		str	r0, [r5]	@ float
  88:Core/Src/accelerometer.c ****     *roll = atan2f(-accel_data.x, sqrtf(accel_data.y * accel_data.y + accel_data.z * accel_data.z))
 374              		.loc 1 88 5 is_stmt 1 view .LVU88
 375              		.loc 1 88 54 is_stmt 0 view .LVU89
 376 0054 28EE088A 		vmul.f32	s16, s16, s16
 377              		.loc 1 88 13 view .LVU90
 378 0058 38EE880A 		vadd.f32	s0, s17, s16
 379 005c FFF7FEFF 		bl	sqrtf
 380              	.LVL19:
 381 0060 F0EE400A 		vmov.f32	s1, s0
 382              		.loc 1 88 13 discriminator 1 view .LVU91
 383 0064 B1EE490A 		vneg.f32	s0, s18
 384 0068 FFF7FEFF 		bl	atan2f
 385              	.LVL20:
 386 006c 10EE100A 		vmov	r0, s0
 387              		.loc 1 88 13 discriminator 2 view .LVU92
 388 0070 FFF7FEFF 		bl	__aeabi_f2d
 389              	.LVL21:
 390              		.loc 1 88 101 discriminator 2 view .LVU93
 391 0074 06A3     		adr	r3, .L12
 392 0076 D3E90023 		ldrd	r2, [r3]
 393 007a FFF7FEFF 		bl	__aeabi_dmul
 394              	.LVL22:
 395 007e FFF7FEFF 		bl	__aeabi_d2f
 396              	.LVL23:
 397              		.loc 1 88 11 discriminator 2 view .LVU94
 398 0082 2060     		str	r0, [r4]	@ float
  89:Core/Src/accelerometer.c **** }
 399              		.loc 1 89 1 view .LVU95
 400 0084 05B0     		add	sp, sp, #20
 401              		.cfi_def_cfa_offset 28
 402              		@ sp needed
 403 0086 BDEC048B 		vldm	sp!, {d8-d9}
 404              		.cfi_restore 82
 405              		.cfi_restore 83
 406              		.cfi_restore 80
 407              		.cfi_restore 81
 408              		.cfi_def_cfa_offset 12
 409 008a 30BD     		pop	{r4, r5, pc}
 410              	.LVL24:
 411              	.L13:
 412              		.loc 1 89 1 view .LVU96
 413 008c AFF30080 		.align	3
 414              	.L12:
 415 0090 F8C1631A 		.word	442745336
 416 0094 DCA54C40 		.word	1078765020
 417              		.cfi_endproc
 418              	.LFE134:
 420              		.section	.text.angles_rate_from_gyro,"ax",%progbits
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 10


 421              		.align	1
 422              		.global	angles_rate_from_gyro
 423              		.syntax unified
 424              		.thumb
 425              		.thumb_func
 427              	angles_rate_from_gyro:
 428              	.LVL25:
 429              	.LFB135:
  90:Core/Src/accelerometer.c **** 
  91:Core/Src/accelerometer.c **** /**
  92:Core/Src/accelerometer.c ****  * @brief Calculates the pitch and roll rates from gyroscope data.
  93:Core/Src/accelerometer.c ****  *
  94:Core/Src/accelerometer.c ****  * This function computes the pitch and roll rates based on the gyroscope's
  95:Core/Src/accelerometer.c ****  * x and y axis readings. The rates are derived directly from the gyroscope data,
  96:Core/Src/accelerometer.c ****  * which provides angular velocity measurements.
  97:Core/Src/accelerometer.c ****  *
  98:Core/Src/accelerometer.c ****  * @param gyro_data Structure containing gyroscope data (x, y, z).
  99:Core/Src/accelerometer.c ****  * @param pitch_rate Pointer to store the calculated pitch rate (in degrees per second).
 100:Core/Src/accelerometer.c ****  * @param roll_rate Pointer to store the calculated roll rate (in degrees per second).
 101:Core/Src/accelerometer.c ****  */
 102:Core/Src/accelerometer.c **** void angles_rate_from_gyro(GyroData gyro_data, float *pitch_rate, float *roll_rate) {
 430              		.loc 1 102 85 is_stmt 1 view -0
 431              		.cfi_startproc
 432              		@ args = 0, pretend = 0, frame = 16
 433              		@ frame_needed = 0, uses_anonymous_args = 0
 434              		@ link register save eliminated.
 435              		.loc 1 102 85 is_stmt 0 view .LVU98
 436 0000 84B0     		sub	sp, sp, #16
 437              		.cfi_def_cfa_offset 16
 438 0002 8DED010A 		vstr.32	s0, [sp, #4]
 439 0006 CDED020A 		vstr.32	s1, [sp, #8]
 440 000a 8DED031A 		vstr.32	s2, [sp, #12]
 103:Core/Src/accelerometer.c ****     *pitch_rate = gyro_data.y; // Gyro Y-axis for pitch rate
 441              		.loc 1 103 5 is_stmt 1 view .LVU99
 442              		.loc 1 103 17 is_stmt 0 view .LVU100
 443 000e C0ED000A 		vstr.32	s1, [r0]
 104:Core/Src/accelerometer.c ****     *roll_rate = gyro_data.x;  // Gyro X-axis for roll rate
 444              		.loc 1 104 5 is_stmt 1 view .LVU101
 445              		.loc 1 104 16 is_stmt 0 view .LVU102
 446 0012 81ED000A 		vstr.32	s0, [r1]
 105:Core/Src/accelerometer.c **** }
 447              		.loc 1 105 1 view .LVU103
 448 0016 04B0     		add	sp, sp, #16
 449              		.cfi_def_cfa_offset 0
 450              		@ sp needed
 451 0018 7047     		bx	lr
 452              		.cfi_endproc
 453              	.LFE135:
 455              		.section	.text.Kalman_Init,"ax",%progbits
 456              		.align	1
 457              		.global	Kalman_Init
 458              		.syntax unified
 459              		.thumb
 460              		.thumb_func
 462              	Kalman_Init:
 463              	.LVL26:
 464              	.LFB136:
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 11


 106:Core/Src/accelerometer.c **** 
 107:Core/Src/accelerometer.c **** /**
 108:Core/Src/accelerometer.c ****  * @brief Initializes the Kalman filter state.
 109:Core/Src/accelerometer.c ****  *
 110:Core/Src/accelerometer.c ****  * This function sets up the initial parameters for the Kalman filter, including
 111:Core/Src/accelerometer.c ****  * the initial state estimate, error covariance, process noise, and measurement noise.
 112:Core/Src/accelerometer.c ****  * It should be called before using the filter for prediction or update steps.
 113:Core/Src/accelerometer.c ****  *
 114:Core/Src/accelerometer.c ****  * @param kf Pointer to the Kalman filter structure to initialize.
 115:Core/Src/accelerometer.c ****  * @param init_state Initial estimate of the state.
 116:Core/Src/accelerometer.c ****  * @param init_covariance Initial estimate of the error covariance.
 117:Core/Src/accelerometer.c ****  * @param process_noise Process noise covariance (Q).
 118:Core/Src/accelerometer.c ****  * @param measurement_noise Measurement noise covariance (R).
 119:Core/Src/accelerometer.c ****  */
 120:Core/Src/accelerometer.c **** void Kalman_Init(Kalman_t *kalman_x, Kalman_t *kalman_y)
 121:Core/Src/accelerometer.c **** {
 465              		.loc 1 121 1 is_stmt 1 view -0
 466              		.cfi_startproc
 467              		@ args = 0, pretend = 0, frame = 0
 468              		@ frame_needed = 0, uses_anonymous_args = 0
 469              		.loc 1 121 1 is_stmt 0 view .LVU105
 470 0000 00B5     		push	{lr}
 471              		.cfi_def_cfa_offset 4
 472              		.cfi_offset 14, -4
 122:Core/Src/accelerometer.c ****     // Initialize Kalman filter parameters for X, Y, and Z axes
 123:Core/Src/accelerometer.c ****     kalman_x->angle = 0.0f;
 473              		.loc 1 123 5 is_stmt 1 view .LVU106
 474              		.loc 1 123 21 is_stmt 0 view .LVU107
 475 0002 0023     		movs	r3, #0
 476 0004 0360     		str	r3, [r0]	@ float
 124:Core/Src/accelerometer.c ****     kalman_x->bias = 0.0f;
 477              		.loc 1 124 5 is_stmt 1 view .LVU108
 478              		.loc 1 124 20 is_stmt 0 view .LVU109
 479 0006 4360     		str	r3, [r0, #4]	@ float
 125:Core/Src/accelerometer.c ****     kalman_x->rate = 0.0f;
 480              		.loc 1 125 5 is_stmt 1 view .LVU110
 481              		.loc 1 125 20 is_stmt 0 view .LVU111
 482 0008 8360     		str	r3, [r0, #8]	@ float
 126:Core/Src/accelerometer.c ****     kalman_x->P[0][0] = 1.0f; // P[0][0]
 483              		.loc 1 126 5 is_stmt 1 view .LVU112
 484              		.loc 1 126 23 is_stmt 0 view .LVU113
 485 000a 4FF07E52 		mov	r2, #1065353216
 486 000e C260     		str	r2, [r0, #12]	@ float
 127:Core/Src/accelerometer.c ****     kalman_x->P[0][1] = 0.0f; // P[0][1]
 487              		.loc 1 127 5 is_stmt 1 view .LVU114
 488              		.loc 1 127 23 is_stmt 0 view .LVU115
 489 0010 0361     		str	r3, [r0, #16]	@ float
 128:Core/Src/accelerometer.c ****     kalman_x->P[1][0] = 0.0f; // P[1][0]
 490              		.loc 1 128 5 is_stmt 1 view .LVU116
 491              		.loc 1 128 23 is_stmt 0 view .LVU117
 492 0012 4361     		str	r3, [r0, #20]	@ float
 129:Core/Src/accelerometer.c ****     kalman_x->P[1][1] = 1.0f; // P[1][1]
 493              		.loc 1 129 5 is_stmt 1 view .LVU118
 494              		.loc 1 129 23 is_stmt 0 view .LVU119
 495 0014 8261     		str	r2, [r0, #24]	@ float
 130:Core/Src/accelerometer.c ****     kalman_x->Q_angle = 0.001f; // Process noise covariance for angle
 496              		.loc 1 130 5 is_stmt 1 view .LVU120
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 12


 497              		.loc 1 130 23 is_stmt 0 view .LVU121
 498 0016 DFED0D7A 		vldr.32	s15, .L18
 499 001a C0ED077A 		vstr.32	s15, [r0, #28]
 131:Core/Src/accelerometer.c ****     kalman_x->Q_bias = 0.003f; // Process noise covariance for bias
 500              		.loc 1 131 5 is_stmt 1 view .LVU122
 501              		.loc 1 131 22 is_stmt 0 view .LVU123
 502 001e DFF830E0 		ldr	lr, .L18+4
 503 0022 C0F820E0 		str	lr, [r0, #32]	@ float
 132:Core/Src/accelerometer.c ****     kalman_x->R_measure = 0.03f; // Measurement noise covariance
 504              		.loc 1 132 5 is_stmt 1 view .LVU124
 505              		.loc 1 132 25 is_stmt 0 view .LVU125
 506 0026 DFF82CC0 		ldr	ip, .L18+8
 507 002a C0F824C0 		str	ip, [r0, #36]	@ float
 133:Core/Src/accelerometer.c **** 
 134:Core/Src/accelerometer.c ****     kalman_y->angle = 0.0f;
 508              		.loc 1 134 5 is_stmt 1 view .LVU126
 509              		.loc 1 134 21 is_stmt 0 view .LVU127
 510 002e 0B60     		str	r3, [r1]	@ float
 135:Core/Src/accelerometer.c ****     kalman_y->bias = 0.0f;
 511              		.loc 1 135 5 is_stmt 1 view .LVU128
 512              		.loc 1 135 20 is_stmt 0 view .LVU129
 513 0030 4B60     		str	r3, [r1, #4]	@ float
 136:Core/Src/accelerometer.c ****     kalman_y->rate = 0.0f;
 514              		.loc 1 136 5 is_stmt 1 view .LVU130
 515              		.loc 1 136 20 is_stmt 0 view .LVU131
 516 0032 8B60     		str	r3, [r1, #8]	@ float
 137:Core/Src/accelerometer.c ****     kalman_y->P[0][0] = 1.0f;
 517              		.loc 1 137 5 is_stmt 1 view .LVU132
 518              		.loc 1 137 23 is_stmt 0 view .LVU133
 519 0034 CA60     		str	r2, [r1, #12]	@ float
 138:Core/Src/accelerometer.c ****     kalman_y->P[0][1] = 0.0f;
 520              		.loc 1 138 5 is_stmt 1 view .LVU134
 521              		.loc 1 138 23 is_stmt 0 view .LVU135
 522 0036 0B61     		str	r3, [r1, #16]	@ float
 139:Core/Src/accelerometer.c ****     kalman_y->P[1][0] = 0.0f;
 523              		.loc 1 139 5 is_stmt 1 view .LVU136
 524              		.loc 1 139 23 is_stmt 0 view .LVU137
 525 0038 4B61     		str	r3, [r1, #20]	@ float
 140:Core/Src/accelerometer.c ****     kalman_y->P[1][1] = 1.0f;
 526              		.loc 1 140 5 is_stmt 1 view .LVU138
 527              		.loc 1 140 23 is_stmt 0 view .LVU139
 528 003a 8A61     		str	r2, [r1, #24]	@ float
 141:Core/Src/accelerometer.c ****     kalman_y->Q_angle = 0.001f;
 529              		.loc 1 141 5 is_stmt 1 view .LVU140
 530              		.loc 1 141 23 is_stmt 0 view .LVU141
 531 003c C1ED077A 		vstr.32	s15, [r1, #28]
 142:Core/Src/accelerometer.c ****     kalman_y->Q_bias = 0.003f;
 532              		.loc 1 142 5 is_stmt 1 view .LVU142
 533              		.loc 1 142 22 is_stmt 0 view .LVU143
 534 0040 C1F820E0 		str	lr, [r1, #32]	@ float
 143:Core/Src/accelerometer.c ****     kalman_y->R_measure = 0.03f;
 535              		.loc 1 143 5 is_stmt 1 view .LVU144
 536              		.loc 1 143 25 is_stmt 0 view .LVU145
 537 0044 C1F824C0 		str	ip, [r1, #36]	@ float
 144:Core/Src/accelerometer.c **** }
 538              		.loc 1 144 1 view .LVU146
 539 0048 5DF804FB 		ldr	pc, [sp], #4
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 13


 540              	.L19:
 541              		.align	2
 542              	.L18:
 543 004c 6F12833A 		.word	981668463
 544 0050 A69B443B 		.word	994352038
 545 0054 8FC2F53C 		.word	1022739087
 546              		.cfi_endproc
 547              	.LFE136:
 549              		.section	.text.Kalman_GetAngle,"ax",%progbits
 550              		.align	1
 551              		.global	Kalman_GetAngle
 552              		.syntax unified
 553              		.thumb
 554              		.thumb_func
 556              	Kalman_GetAngle:
 557              	.LVL27:
 558              	.LFB137:
 145:Core/Src/accelerometer.c **** 
 146:Core/Src/accelerometer.c **** /**
 147:Core/Src/accelerometer.c ****  * @brief Computes the filtered angle using the Kalman filter algorithm.
 148:Core/Src/accelerometer.c ****  *
 149:Core/Src/accelerometer.c ****  * This function estimates the true angle by combining accelerometer and gyroscope data,
 150:Core/Src/accelerometer.c ****  * reducing noise and drift. It performs the prediction and update steps of the Kalman filter
 151:Core/Src/accelerometer.c ****  * to provide a more accurate and stable angle estimate. The kalman filter works for the pitch and 
 152:Core/Src/accelerometer.c ****  *
 153:Core/Src/accelerometer.c ****  * @param kalman Pointer to the Kalman filter structure for the axis.
 154:Core/Src/accelerometer.c ****  * @param acc_angle Angle measured from the accelerometer (in degrees).
 155:Core/Src/accelerometer.c ****  * @param gyro_rate Angular rate measured from the gyroscope (in degrees per second).
 156:Core/Src/accelerometer.c ****  * @param dt Time interval since the last update (in seconds).
 157:Core/Src/accelerometer.c ****  */
 158:Core/Src/accelerometer.c **** void Kalman_GetAngle(Kalman_t *kalman, float acc_angle, float gyro_rate, float dt) {
 559              		.loc 1 158 84 is_stmt 1 view -0
 560              		.cfi_startproc
 561              		@ args = 0, pretend = 0, frame = 0
 562              		@ frame_needed = 0, uses_anonymous_args = 0
 563              		@ link register save eliminated.
 159:Core/Src/accelerometer.c ****     // 1. Prediction
 160:Core/Src/accelerometer.c ****     kalman->rate = gyro_rate - kalman->bias;
 564              		.loc 1 160 5 view .LVU148
 565              		.loc 1 160 38 is_stmt 0 view .LVU149
 566 0000 D0ED014A 		vldr.32	s9, [r0, #4]
 567              		.loc 1 160 30 view .LVU150
 568 0004 70EEE40A 		vsub.f32	s1, s1, s9
 569              	.LVL28:
 570              		.loc 1 160 18 view .LVU151
 571 0008 C0ED020A 		vstr.32	s1, [r0, #8]
 161:Core/Src/accelerometer.c ****     kalman->angle += dt * kalman->rate;
 572              		.loc 1 161 5 is_stmt 1 view .LVU152
 573              		.loc 1 161 11 is_stmt 0 view .LVU153
 574 000c 90ED005A 		vldr.32	s10, [r0]
 575              		.loc 1 161 25 view .LVU154
 576 0010 60EE810A 		vmul.f32	s1, s1, s2
 577              		.loc 1 161 19 view .LVU155
 578 0014 35EE205A 		vadd.f32	s10, s10, s1
 579 0018 80ED005A 		vstr.32	s10, [r0]
 162:Core/Src/accelerometer.c **** 
 163:Core/Src/accelerometer.c ****     // state covariance update
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 14


 164:Core/Src/accelerometer.c ****     kalman->P[0][0] += dt * (dt*kalman->P[1][1] - kalman->P[0][1] - kalman->P[1][0] + kalman->Q_ang
 580              		.loc 1 164 5 is_stmt 1 view .LVU156
 581              		.loc 1 164 17 is_stmt 0 view .LVU157
 582 001c D0ED037A 		vldr.32	s15, [r0, #12]
 583              		.loc 1 164 45 view .LVU158
 584 0020 90ED066A 		vldr.32	s12, [r0, #24]
 585              		.loc 1 164 32 view .LVU159
 586 0024 26EE014A 		vmul.f32	s8, s12, s2
 587              		.loc 1 164 63 view .LVU160
 588 0028 90ED047A 		vldr.32	s14, [r0, #16]
 589              		.loc 1 164 49 view .LVU161
 590 002c 74EE475A 		vsub.f32	s11, s8, s14
 591              		.loc 1 164 81 view .LVU162
 592 0030 D0ED056A 		vldr.32	s13, [r0, #20]
 593              		.loc 1 164 67 view .LVU163
 594 0034 75EEE65A 		vsub.f32	s11, s11, s13
 595              		.loc 1 164 93 view .LVU164
 596 0038 D0ED073A 		vldr.32	s7, [r0, #28]
 597              		.loc 1 164 85 view .LVU165
 598 003c 75EEA35A 		vadd.f32	s11, s11, s7
 599              		.loc 1 164 27 view .LVU166
 600 0040 65EE815A 		vmul.f32	s11, s11, s2
 601              		.loc 1 164 21 view .LVU167
 602 0044 77EEA57A 		vadd.f32	s15, s15, s11
 603 0048 C0ED037A 		vstr.32	s15, [r0, #12]
 165:Core/Src/accelerometer.c ****     kalman->P[0][1] -= dt * kalman->P[1][1];
 604              		.loc 1 165 5 is_stmt 1 view .LVU168
 605              		.loc 1 165 21 is_stmt 0 view .LVU169
 606 004c 37EE447A 		vsub.f32	s14, s14, s8
 607 0050 80ED047A 		vstr.32	s14, [r0, #16]
 166:Core/Src/accelerometer.c ****     kalman->P[1][0] -= dt * kalman->P[1][1];
 608              		.loc 1 166 5 is_stmt 1 view .LVU170
 609              		.loc 1 166 21 is_stmt 0 view .LVU171
 610 0054 76EEC46A 		vsub.f32	s13, s13, s8
 611 0058 C0ED056A 		vstr.32	s13, [r0, #20]
 167:Core/Src/accelerometer.c ****     kalman->P[1][1] += kalman->Q_bias * dt;
 612              		.loc 1 167 5 is_stmt 1 view .LVU172
 613              		.loc 1 167 30 is_stmt 0 view .LVU173
 614 005c D0ED085A 		vldr.32	s11, [r0, #32]
 615              		.loc 1 167 39 view .LVU174
 616 0060 65EE815A 		vmul.f32	s11, s11, s2
 617              		.loc 1 167 21 view .LVU175
 618 0064 36EE256A 		vadd.f32	s12, s12, s11
 619 0068 80ED066A 		vstr.32	s12, [r0, #24]
 168:Core/Src/accelerometer.c **** 
 169:Core/Src/accelerometer.c ****     // 2. update
 170:Core/Src/accelerometer.c ****     float y = acc_angle - kalman->angle; // innovation
 620              		.loc 1 170 5 is_stmt 1 view .LVU176
 621              		.loc 1 170 11 is_stmt 0 view .LVU177
 622 006c 30EE450A 		vsub.f32	s0, s0, s10
 623              	.LVL29:
 171:Core/Src/accelerometer.c ****     float S = kalman->P[0][0] + kalman->R_measure; // incertitude innovation
 624              		.loc 1 171 5 is_stmt 1 view .LVU178
 625              		.loc 1 171 39 is_stmt 0 view .LVU179
 626 0070 90ED094A 		vldr.32	s8, [r0, #36]
 627              		.loc 1 171 11 view .LVU180
 628 0074 37EE844A 		vadd.f32	s8, s15, s8
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 15


 629              	.LVL30:
 172:Core/Src/accelerometer.c ****     float K0 = kalman->P[0][0] / S;
 630              		.loc 1 172 5 is_stmt 1 view .LVU181
 631              		.loc 1 172 11 is_stmt 0 view .LVU182
 632 0078 C7EE845A 		vdiv.f32	s11, s15, s8
 633              	.LVL31:
 173:Core/Src/accelerometer.c ****     float K1 = kalman->P[1][0] / S;
 634              		.loc 1 173 5 is_stmt 1 view .LVU183
 635              		.loc 1 173 11 is_stmt 0 view .LVU184
 636 007c C6EE843A 		vdiv.f32	s7, s13, s8
 637              	.LVL32:
 174:Core/Src/accelerometer.c **** 
 175:Core/Src/accelerometer.c ****     // state update
 176:Core/Src/accelerometer.c ****     kalman->angle += K0 * y;
 638              		.loc 1 176 5 is_stmt 1 view .LVU185
 639              		.loc 1 176 25 is_stmt 0 view .LVU186
 640 0080 20EE254A 		vmul.f32	s8, s0, s11
 641              	.LVL33:
 642              		.loc 1 176 19 view .LVU187
 643 0084 35EE045A 		vadd.f32	s10, s10, s8
 644 0088 80ED005A 		vstr.32	s10, [r0]
 177:Core/Src/accelerometer.c ****     kalman->bias  += K1 * y;
 645              		.loc 1 177 5 is_stmt 1 view .LVU188
 646              		.loc 1 177 25 is_stmt 0 view .LVU189
 647 008c 20EE230A 		vmul.f32	s0, s0, s7
 648              	.LVL34:
 649              		.loc 1 177 19 view .LVU190
 650 0090 74EE804A 		vadd.f32	s9, s9, s0
 651 0094 C0ED014A 		vstr.32	s9, [r0, #4]
 178:Core/Src/accelerometer.c **** 
 179:Core/Src/accelerometer.c ****     // state covariance update
 180:Core/Src/accelerometer.c ****     float P00_temp = kalman->P[0][0];
 652              		.loc 1 180 5 is_stmt 1 view .LVU191
 653              	.LVL35:
 181:Core/Src/accelerometer.c ****     float P01_temp = kalman->P[0][1];
 654              		.loc 1 181 5 view .LVU192
 182:Core/Src/accelerometer.c **** 
 183:Core/Src/accelerometer.c ****     kalman->P[0][0] -= K0 * P00_temp;
 655              		.loc 1 183 5 view .LVU193
 656              		.loc 1 183 27 is_stmt 0 view .LVU194
 657 0098 27EEA55A 		vmul.f32	s10, s15, s11
 658              		.loc 1 183 21 view .LVU195
 659 009c 37EEC55A 		vsub.f32	s10, s15, s10
 660 00a0 80ED035A 		vstr.32	s10, [r0, #12]
 184:Core/Src/accelerometer.c ****     kalman->P[0][1] -= K0 * P01_temp;
 661              		.loc 1 184 5 is_stmt 1 view .LVU196
 662              		.loc 1 184 27 is_stmt 0 view .LVU197
 663 00a4 67EE255A 		vmul.f32	s11, s14, s11
 664              	.LVL36:
 665              		.loc 1 184 21 view .LVU198
 666 00a8 77EE655A 		vsub.f32	s11, s14, s11
 667 00ac C0ED045A 		vstr.32	s11, [r0, #16]
 185:Core/Src/accelerometer.c ****     kalman->P[1][0] -= K1 * P00_temp;
 668              		.loc 1 185 5 is_stmt 1 view .LVU199
 669              		.loc 1 185 27 is_stmt 0 view .LVU200
 670 00b0 67EEA37A 		vmul.f32	s15, s15, s7
 671              	.LVL37:
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 16


 672              		.loc 1 185 21 view .LVU201
 673 00b4 76EEE76A 		vsub.f32	s13, s13, s15
 674 00b8 C0ED056A 		vstr.32	s13, [r0, #20]
 186:Core/Src/accelerometer.c ****     kalman->P[1][1] -= K1 * P01_temp;
 675              		.loc 1 186 5 is_stmt 1 view .LVU202
 676              		.loc 1 186 27 is_stmt 0 view .LVU203
 677 00bc 27EE237A 		vmul.f32	s14, s14, s7
 678              	.LVL38:
 679              		.loc 1 186 21 view .LVU204
 680 00c0 36EE476A 		vsub.f32	s12, s12, s14
 681 00c4 80ED066A 		vstr.32	s12, [r0, #24]
 187:Core/Src/accelerometer.c **** }
 682              		.loc 1 187 1 view .LVU205
 683 00c8 7047     		bx	lr
 684              		.cfi_endproc
 685              	.LFE137:
 687              		.text
 688              	.Letext0:
 689              		.file 2 "/Users/benjamincastin/Library/Application Support/Code/User/globalStorage/bmd.stm32-for-v
 690              		.file 3 "/Users/benjamincastin/Library/Application Support/Code/User/globalStorage/bmd.stm32-for-v
 691              		.file 4 "Drivers/CMSIS/Device/ST/STM32L4xx/Include/stm32l476xx.h"
 692              		.file 5 "Drivers/STM32L4xx_HAL_Driver/Inc/stm32l4xx_hal_def.h"
 693              		.file 6 "Drivers/STM32L4xx_HAL_Driver/Inc/stm32l4xx_hal_dma.h"
 694              		.file 7 "Drivers/STM32L4xx_HAL_Driver/Inc/stm32l4xx_hal_i2c.h"
 695              		.file 8 "Core/Inc/accelerometer.h"
 696              		.file 9 "/Users/benjamincastin/Library/Application Support/Code/User/globalStorage/bmd.stm32-for-v
ARM GAS  /var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s 			page 17


DEFINED SYMBOLS
                            *ABS*:00000000 accelerometer.c
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:21     .text.Accelerometer_Init:00000000 $t
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:27     .text.Accelerometer_Init:00000000 Accelerometer_Init
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:137    .text.Accelerometer_Read:00000000 $t
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:143    .text.Accelerometer_Read:00000000 Accelerometer_Read
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:306    .text.Accelerometer_Read:0000011c $d
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:312    .text.angles_from_accel:00000000 $t
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:318    .text.angles_from_accel:00000000 angles_from_accel
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:415    .text.angles_from_accel:00000090 $d
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:421    .text.angles_rate_from_gyro:00000000 $t
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:427    .text.angles_rate_from_gyro:00000000 angles_rate_from_gyro
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:456    .text.Kalman_Init:00000000 $t
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:462    .text.Kalman_Init:00000000 Kalman_Init
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:543    .text.Kalman_Init:0000004c $d
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:550    .text.Kalman_GetAngle:00000000 $t
/var/folders/jp/0qc3z4h55h9f6h172k8821nw0000gn/T//ccTWTkE8.s:556    .text.Kalman_GetAngle:00000000 Kalman_GetAngle

UNDEFINED SYMBOLS
HAL_I2C_Mem_Read
HAL_I2C_Mem_Write
sqrtf
atan2f
__aeabi_f2d
__aeabi_dmul
__aeabi_d2f
